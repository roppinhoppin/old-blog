---
layout: post
title: "KVM/ARM Internals Part.1"
---

<!-- TOC -->

- [ARM Virtualization Extensions](#arm-virtualization-extensions)
    - [CPU仮想化](#cpu仮想化)
    - [メモリ仮想化](#メモリ仮想化)
    - [割り込み仮想化](#割り込み仮想化)
    - [タイマー仮想化](#タイマー仮想化)
    - [x86との比較](#x86との比較)
- [KVM/ARMのアーキテクチャ](#kvmarmのアーキテクチャ)
    - [Split-mode Virtualization](#split-mode-virtualization)
    - [KVM/ARMのCPUに関する実装](#kvmarmのcpuに関する実装)
    - [KVM/ARMのメモリに関する実装](#kvmarmのメモリに関する実装)
    - [KVM/ARMのI/Oに関する実装](#kvmarmのioに関する実装)
    - [KVM/ARMの割り込みに関する実装](#kvmarmの割り込みに関する実装)
    - [KVM/ARMのタイマーに関する実装](#kvmarmのタイマーに関する実装)
- [まとめ](#まとめ)
- [参考文献](#参考文献)

<!-- /TOC -->

Part1では，KVM/ARMの基本となるARMアーキテクチャに内蔵されている機能や細かい術語について記述していく．

KVM/ARMは，split-mode virtualizationというアプローチを用いて，コアとなるハイパーバイザーKVM HighvisorとKVM Lowvisorに分割して，それぞれの実行モードで得られる利点を利用しようという試みがなされている．この手法はARMの仮想化では非常に重要となる機能でARMはHypervisorを動かすための実行モードとしてHypモードという実行モードが用意されており，Hypモードはカーネルモードなどとは異なる独自の機能を用意されている．設計としては，HighvisorではLinuxカーネルに用意されている機能をカーネル自体のコードの改変をせずに行い，また同時にLowvisorではHypモードの利点を生かしARMのハードウェア仮想化機能を用いる．
![lowvisor-and-highvisor](/images/2019/08/lowvisor-and-highvisor.png)

## ARM Virtualization Extensions
このセクションではARMが提供しているVirtualization Extensionsの実装について述べる．

### CPU仮想化
![secure-and-nonsecure-world](/images/2019/08/secure-and-nonsecure-world.png)
上の図はARMv7の実行モードの図で，TrustZoneを含む新しい実行モードがHypモードと呼ばれる．
TrustZoneはsecure worldとnon-secure worldという二つの分離された実行空間を持っている．TrustZoneは一見secure world内で仮想化をする便利な機能に見えるが，secure world内ではハードウェア側でtrap-and-emulate機能を有していない．またnon-secure worldの実行をsecure world側がtrapするわけでもない．すなわちVirtualization Extensionが提供する仮想化は全てnon-secure world内で一番権限の高いEL2レイヤー(図内ではPL2)で行われることである．またnon-secure world内で一番権限レベルの高い実行モードを有しているレイヤーは全てのnon-secure worldの物理メモリに対してアクセス可能である．が，しかしこの機能によってnon-secure world内で動いている複数のVMを分離できない仕様になっている．（VMごとの対応するメモリアドレスがオーバーラップしてしまうため．)
そして，Hyp modeはnon-secure worldでのtrap-and-emulateを使った仮想化技術であり，ハードウェアに対してセンシティブな命令およびハードウェア割り込みなどが発生した時にカーネルを実行している実行モード(EL1)からトラップできるようにハードウェア側に設定できるような機能を有している．
またARMのアーキテクチャが用意している機能で，仮想化のオーバーヘッドを減らすために，例えば，システムコールやページフォルトなどで発生した割り込み命令に対してその割り込み命令がハイパーバイザー側にトラップされるのではなく直接ゲストのカーネルに対して処理されるようにする機能などがある．
しかし，ARM社はハイパーバイザー開発者に対してよりシンプルにハイパーバイザーを実装してもらうために，Hypモードはカーネルモードに比べて少ない制御レジスタしか実装されていない．
同じく，ARMはHypモードのページテーブルのエントリには特定のビットを立てていてユーザー空間の他のソフトウェアとページテーブルを共有しないように分離されている．

### メモリ仮想化
ARMは物理メモリを仮想化するハードウェア支援の機能も用意しており，VMから見た物理アドレスであるIPA(_Intermediate Physical Address_)またの名を _guest physical address_ をホスト側の物理アドレス( _physical address_ (PAs), _host physical address_)に変換する機能が必要となる．x86のEPTがARMのこの機能の等価の機能となる．この機能は一般にSLAT(Second Level Address Translation)またnested page tableと呼ばれ，ARMでは**Stage-2 page table**と呼ばれている．
またこのStage-2 page tableはARMのLPAEというページテーブルのフォーマットに即しているが，Hypモードで使われるページテーブルはカーネルモードで使われているそれとは少しだけ異なる．

### 割り込み仮想化
GIC(Generic Interrupt Controller)は，デバイスからのCPUに対する割り込みをルーティングしたり，CPU側に入った割り込みをCPUがGICに対して割り込み元の情報を提供する．
GICは特にマルチコアのシステムで重要となり，GICは _Inter-Processor Interrupts_ (IPI)と呼ばれる一つのCPUのコアからもう一つのCPUのコアに対する割り込み捌いたりする命令を生成する機能として使われる．
GICは，distributorとCPUのインターフェイスという二つのパーツから構成されており，どちらもMMIO(Memory-Mapped Interface)越しにアクセスされる．　
IPIはACKとEOI(End-Of-Interrupt)が用意されており，このシグナルがコアごとに送られる．
しかしこれら全ての割り込みをハイパーバイザーがトラップして処理するのは非常に厄介でかつコストの高い行為(コンテキストスイッチが大量に発生するため)
そのためARMでは _virtual GIC_ (VGIC)という機能が備わっており仮想割り込みを受け取れるので，ソフトウェア上（ハイパーバイザー）で処理する必要がなくなる．
またVM内では，それぞれのCPUに実装されているVGICのインターフェイスを見るように設計されている．
仮想割り込みは _list registers_ という特別に用意されたレジスタに書き込むことでなされる．
CPU上に実装されているVGICのインターフェイスは直接VMのカーネルモードに対して仮想割り込みを発生させられる．
しかし _distributor_　はまだソフトウェア的にエミュレーションする必要があり，全ての _distributor_ に対するアクセスはハイパーバイザー側にトラップされる必要がある．

### タイマー仮想化
Generic Timerは，_counter_ は実際にすぎた時間を測り，_timer_ はそれぞれのCPUに対して割り当てられており，ある時間が経過した時にCPUに対して割り込み命令を発生させる．
_Timer_ はゲストOSでもハイパーバイザーでも独立に使うことが想定されているため _timer_ の実装は分離されていてかつゲストOSがその制御を保持してなければならない．
そのため仮想化支援機構では，_virtual counter_ と _virtual timer_ をそれぞれ設けてVMも _timer_ に対してアクセスしたりプログラムがHypモードへのトラップなしで行えるようになっている．

<!--
### x86との比較
ARMの仮想化は分離された実行モードという形で実装されており，カーネルモードより権限の高い実行モードで実装されている．
Intelの仮想化はrootとnon-rootモードの二つとして実装されておりCPU保護モードとして別々に実装されている．


センシティブ命令の処理のされ方も，ARMではセンシティブ命令は全てHypモードにトラップされるが，Intelではセンシティブ命令はnon-rootモードからrootモードに同じ保護レベルにいる間はトラップされる．
-->

## KVM/ARMのアーキテクチャ
この章では，KVM/ARMが実際どのようにVirtulization Extensionを用いて仮想化のフレームワークをLinuxカーネル内に実装したかを述べる．
また，KVM/ARMの実装上メインの問題としてVirtualization Extensionは仕様としてスタンドアロンのハイパーバイザーを想定しているため，ハイパーバイザーはカーネルの機能から分離されることが望まれている．

### Split-mode Virtualization
KVM/ARMをHypモードで動かすことには少なくとも二つの問題が存在する．

1. Linuxに実装されている低レイヤー向けのコードはすべてカーネルモードで動くことが想定されているため無修正のHypモードでは動かない．
    Hypモードなしでハードウェアとの対応をするためのコードを保持し，ゲストOSとしてLinuxを動かすには低レベルなコードをHypモードとカーネルモード両方で書く必要があり，結果的に低速化とスパゲティコードを招くことになる．
2. Linuxカーネル本体をそのままHypモードで動かすことは非常に実機でのパフォーマンスに影響を与える．
    Hypモードは単一のページテーブルのレジスタを持っているためユーザー空間にあるプログラムに直接アクセスできない．
    よく呼ばれるユーザー空間のデータに対するアクセスがあるデータを扱う関数は，明示的にユーザー空間のデータをカーネルのアドレス空間にマッピングし，その後に必要となる処理やTLBのメンテナンスをする．

そこで，使うのがSplit-mode Virtualizationという概念で，lowvisorとhighvisorというモジュールに分割して処理を行う．
![lowvisor-and-highvisor](/images/2019/08/lowvisor-and-highvisor.png)

Lowvisorは，Hypモードで有効なハードウェアの仮想化支援機構を利用するために用いられる．
1つ目のlowvisorの機能は，正しい実行コンテキストを設定しハードウェアのコンフィグを設定する．
また異なる実行コンテキストで保護機能や分離機能を強制したりする．
2つ目は，VMの実行コンテキストからホストの実行コンテキストにスイッチしたりそのまた逆をする機能を持っている．
3つ目は，仮想トラップハンドラを提供する．仮想トラップハンドラとは，ハイパーバイザーが処理するべき割り込みや例外をハンドルする機能である．
この実装の利点はセキュリティ的にクリティカルなバグを産みやすくなるコードベースを減らすことができるため構造上セキュアになっている．

Highvisorは，Linuxカーネルの一部としてカーネルモードでうご言うているプログラムで，lowvisorよりリッチな機能を提供する．
Linuxカーネルの関数を用いることでhighvisorが複雑な機能を簡単に実装できることを可能にしている．

しかしsplit-mode virtulizationは二回トラップが挟まる(ゲストOS->lowvisor->highvisor)ためコンテキストスイッチがより多く発生し，VMの実行速度に問題を与えるのではないかという懸念がある．
これらの余分なトラップはパフォーマンスに対して影響を与えないと言う結果がでている，（論文参照）

HighvisorとlowvisorはMMIOのインターフェイスを通じてデータを共有している．
HighvisorがLinuxカーネルのメモリ管理のコードを再利用可能なことから，highvisorは明示的にHypモードで実行されている全てのコードと全てのデータを保持しているHypモードのページテーブルを管理している．

### KVM/ARMのCPUに関する実装
CPUを仮想化するために，KVM/ARMはVMに対して，ハイパーバイザーはハードウェアの制御下にありつつ，実機のハードウェア上で動いているCPUと本質的に同じインターフェイスを提供しなければならない．
また，VMは必ず同じレジスタの状態に恒久的なアクセスを持っていることが必要である．
ハイパーバイザーのハードウェア状態になんらかの影響をあたえたり，VMに対してinformation leakageを起こしそうなものは仮想化による抽象化に違反するものは，KVM/ARMはセンシティブ命令が発行された時にトラップとエミュレートが行われる．

![table1](/images/2019/08/table1.png)
上の表は，カーネルとユーザーモードで動いているソフトウェアから見えるレジスタの種類と，KVM/ARMのそれぞれのレジスタに対しての仮想化メソッドについて書いている．
lowvisorはlowvisor専用の設定するレジスタを確保しているが上の表では示されていない．

KVM/ARMは，world-switch（カーネルモード，ユーザーモードからHypモードにスイッチする時，そのまた逆も）の時にコンテキストスイッチを起こす．

world-switchが**ホストからVMに起こるとき**に行われる動作は以下の通りになっている．

1. Hypスタックに全てのGPレジスタを退避させる
2. VMにVGICを設定する
3. VMにタイマーを設定する
4. host-specificなレジスタをHypスタックに退避させる
5. VMに設定するレジスタをハードウェア側に読み込ませる
6. 浮動小数点演算の命令，CPU halt命令，SMC命令，特定のレジスタに対するアクセス，デバッグレジスタに対するアクセスをHypモードにトラップされるように設定する
7. VM-specific IDをshadow IDレジスタに書き込む
8. Stage-2 page table base registerをセットしstage-2 address translationを有効にする
9. guestの全てのGPレジスタをリストアする
10. ユーザーモードかカーネルモードにトラップさせる

world-switchが**VMからホストに起こるとき**に行われる動作は以下の通りになる．
1. VMのGPレジスタをストアする
2. Stage-2 translationをオフにする
3. 特定のレジスタのアクセスや命令でHypモードがトラップしないように設定する
4. 全てのVM-specificなレジスタを保存する
5. ホストの設定レジスタをハードウェア上に読み込ませる
6. ホストにタイマーを設定する
7. VM-specificなVGICのstateを保存する
8. 全てのホストのGPレジスタを復元させる
9. カーネルモードへとトラップさせる


### KVM/ARMのメモリに関する実装
KVM/ARMはメモリの仮想化としてStage-2 translationをVM内全てのメモリアクセスに対して有効にしている．
また，Stage-2 translationはHypモードでのみ設定可能で，VMと完全に透過のページテーブルになっている．
highivsorはStage-2 translationページテーブルを管理していて，VMが設定したメモリ以外へのメモリアクセスを許可しないようにしている．
（それ以外へのメモリアクセスはStage-2 page faultとなりハイパーバイザーにハンドリングされる．
この手法は，VMに自分が確保しているメモリ領域以外の箇所（ハイパーバイザーや他のVM）へのアクセスをさせないようにしている．

KVM/ARMではsplit-mode virtualizationを用いてカーネル内に存在する既存のメモリアロケーターやページの参照カウンター，ページテーブルを操作するコードを使用する．KVM/ARMではStage-2 page faultをIPA(_Intermediate Physical Address_)を元に判断し，もしアドレスがVMのメモリマップ上の普通のメモリの場合には，KVM/ARMがその領域のためのページをカーネル内のメモリアロケーターを通じて適宜作成する．


### KVM/ARMのI/Oに関する実装
KVM/ARMは，QEMUやVirtioのユーザー空間でのエミュレーションをする機能を用いてI/Oのエミュレーションをしている．
ハードウェアレベルでは，ARMでは全てのI/O処理はMMIOのデバイスの領域をload/store命令で行う．
KVM/ARMでは，VMにアサインされているデバイス以外はStage-2 translationを用いて物理デバイスにVMからアクセスをできないようにしている．
VMに確保されているメモリ以外のアクセスは全てハイパーバイザーにトラップされ，そのfaultが起きたアドレスを元に，QEMUがエミューレションしているデバイスにルーティングされる．

### KVM/ARMの割り込みに関する実装
KVM/ARMではCPUの全てのハードウェア割り込みをHypモードにトラップするように設定する．
ホスト上でかつhighvisorでプログラムが実行されている時では割り込みはHypモードを通過するオーバーヘッドをなくすため直接カーネルモードにトラップされる．また全てのハードウェア割り込みの処理はホスト内で既存のLinuxの割り込みハンドリング機能を用いて行われる．

しかし，VMはエミュレートしているデバイスから仮想割り込みの形で通知を受け取らなければならず，さらにマルチコアを使用するゲストOSでは仮想IPI(Inter-Processor interrupt)を一つの仮想コアからもう一つの仮想コアに送れるようになる必要がある．
そこでKVM/ARMではVGICを仮想割り込みをVMに注入することでHypモードにトラップされる割り込みの数を減らしている．
またVMが直接VGICの仮想CPUインターフェイスにアクセスできるように，KVM/ARMではStage-2 page tableに細工をし，VM側からVGICのlist registerのみを読み出せるように設定している．
しかしゲストOS側がGIC distributorにアクセスしてIPIを送ろうとすることがあるが，そのようなアクセスは全てハイパーバイザー側でトラップされてdistributorがエミュレーションされる．
その機能はvirtual distributorと呼ばれhighvisorの一部として動いている．
virtual distributorは内部のソフトウェアの状態，例えばそれぞれの割り込みの状態やその状態を使ってVMがいつスケジュールされて仮想割り込みを注入するかなどを保存している．

留意しなければならないことの一つとして，VMにスイッチしている状態でハイパーバイザーが一度仮想割り込みをlist registerに書き込んだ時，virtual distibutorはlist registerをハイパーバイザーにスイッチする時にまた読み直す必要があるということ．
これは，list registerが仮想割り込みに関する情報を保持しているためである．
KVM/ARMでは完全にlist registerを含む全てのVGICの状態をコンテキストスイッチするというシンプルな方法でこの問題を解決している．

### KVM/ARMのタイマーに関する実装
一般的なOSにおいて，タイマーのカウンターを読んだり，タイマー自体をプログラムすることは，OSがプロセスをスケジューリングしたり，デバイスの状態をポーリングしたりなどでは頻繁に行われる命令である．
Linuxでは，タイマーのカウンターを読むことでプロセスのタイム スライスがexpireしたかどうか確認する．またLinuxでは，タイマーを使って，プロセスがそのプロセスに確保されたタイム スライスを超えないようにプログラムしている．

KVM/ARMでは，ARMのハードウェア仮想化支援機能であるCPUごとに割り当てられているタイマー(generic timer)の仮想化機能を用いて，VMがHypモードにトラップされることなく，カウンターを読んだり，タイマーをプログラムできるようにしている．
しかし，仮想タイマーは仮想割り込み命令を発行せずハードウェア割り込みを吐き，ハイパーバイザーにトラップされる構造になっている．
KVM/ARMでは，VMの仮想タイマーがexpireした時には対応する仮想割り込みをVMに送り，highvisor内でACKとEOI命令を処理する．

またもう一つの問題点として，ハードウェアは物理CPU一つに対して一つの仮想タイマーしか提供していないため，一つのハードウェアインスタンスで複数の仮想CPUを用いる場合，仮想CPUは複雑に多重化してしまう．
この状況に対応するためKVM/ARMでは，VMがハイパーバイザーにトラップされた時にunexpiredなタイマーを検知し，既存のOSの機能を用いて仮想タイマーが発火されたときにソフトウェアタイマーが発火されるように設定しVMを実行されたままにする．
そしてそのようなソフトウェアタイマーが発火した時にはコールバック関数が呼び出され，仮想タイマーによる仮想割り込みをvirtual distributorを用いてVMに送る．

## まとめ
今回はKVM/ARMの実装の理論について述べたが次のパートではそれの実際の実装について触れていきたい．

## 参考文献
<https://www.cs.columbia.edu/~nieh/pubs/asplos2014_kvmarm.pdf>